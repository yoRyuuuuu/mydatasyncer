
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mydatasyncer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yoRyuuuuu/mydatasyncer/config.go (53.5%)</option>
				
				<option value="file1">github.com/yoRyuuuuu/mydatasyncer/dbsync.go (84.3%)</option>
				
				<option value="file2">github.com/yoRyuuuuu/mydatasyncer/loader.go (95.6%)</option>
				
				<option value="file3">github.com/yoRyuuuuu/mydatasyncer/main.go (60.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/goccy/go-yaml"
)

// DBConfig represents database connection settings
type DBConfig struct {
        DSN string `yaml:"dsn"` // Data Source Name (example: "user:password@tcp(127.0.0.1:3306)/dbname")
}

// SyncConfig represents data synchronization settings
type SyncConfig struct {
        FilePath         string   `yaml:"filePath"`         // Input file path
        TableName        string   `yaml:"tableName"`        // Target table name
        Columns          []string `yaml:"columns"`          // DB column names corresponding to file columns (order is important)
        TimestampColumns []string `yaml:"timestampColumns"` // Column names to set current timestamp on insert/update
        ImmutableColumns []string `yaml:"immutableColumns"` // Column names that should not be updated in diff mode
        PrimaryKey       string   `yaml:"primaryKey"`       // Primary key column name (required for differential update)
        SyncMode         string   `yaml:"syncMode"`         // "overwrite" or "diff" (differential)
        DeleteNotInFile  bool     `yaml:"deleteNotInFile"`  // Whether to delete records not in file when using diff mode
}

// Config represents configuration information
type Config struct {
        DB     DBConfig   `yaml:"db"`
        Sync   SyncConfig `yaml:"sync"`
        DryRun bool       `yaml:"dryRun"` // Enable dry-run mode
}

// NewDefaultConfig returns a Config struct with default values
func NewDefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                DB: DBConfig{
                        DSN: "user:password@tcp(127.0.0.1:3306)/testdb?parseTime=true",
                },
                Sync: SyncConfig{
                        FilePath:         "./testdata.csv",
                        TableName:        "products",
                        Columns:          []string{"id", "name", "price"}, // Match CSV column order
                        PrimaryKey:       "id",
                        SyncMode:         "diff", // "overwrite" or "diff"
                        DeleteNotInFile:  true,
                        TimestampColumns: []string{}, // Default to empty slice
                        ImmutableColumns: []string{}, // Default to empty slice
                },
        }
}</span>

// LoadConfig loads configuration from file specified by configPath
// Falls back to default configuration if the file doesn't exist or contains errors
func LoadConfig(configPath string) Config <span class="cov8" title="1">{
        // If no config path is provided, use the default
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = "mydatasyncer.yml"
        }</span>

        // Check for the config file
        <span class="cov8" title="1">data, err := os.ReadFile(configPath)

        // If config file not found or error reading, use default configuration
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Printf("Config file '%s' not found. Using default configuration.\n", configPath)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Warning: Error reading config file %s: %v\n", configPath, err)
                        fmt.Println("Using default configuration")
                }</span>
                <span class="cov0" title="0">return NewDefaultConfig()</span>
        }

        <span class="cov8" title="1">fmt.Printf("Using config file: %s\n", configPath)

        var cfg Config
        err = yaml.Unmarshal(data, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Could not parse config file %s: %v\n", configPath, err)
                fmt.Println("Using default configuration")
                return NewDefaultConfig()
        }</span>

        // Set default values for fields not specified in the config file
        <span class="cov8" title="1">setDefaultsIfNeeded(&amp;cfg)

        return cfg</span>
}

// setDefaultsIfNeeded sets default values for fields that are not specified in the config file
func setDefaultsIfNeeded(cfg *Config) <span class="cov8" title="1">{
        defaultCfg := NewDefaultConfig()

        // DB defaults
        if cfg.DB.DSN == "" </span><span class="cov0" title="0">{
                cfg.DB.DSN = defaultCfg.DB.DSN
        }</span>

        // Sync defaults
        <span class="cov8" title="1">if cfg.Sync.FilePath == "" </span><span class="cov0" title="0">{
                cfg.Sync.FilePath = defaultCfg.Sync.FilePath
        }</span>
        <span class="cov8" title="1">if cfg.Sync.TableName == "" </span><span class="cov0" title="0">{
                cfg.Sync.TableName = defaultCfg.Sync.TableName
        }</span>
        <span class="cov8" title="1">if len(cfg.Sync.Columns) == 0 </span><span class="cov0" title="0">{
                cfg.Sync.Columns = defaultCfg.Sync.Columns
        }</span>
        <span class="cov8" title="1">if cfg.Sync.PrimaryKey == "" </span><span class="cov0" title="0">{
                cfg.Sync.PrimaryKey = defaultCfg.Sync.PrimaryKey
        }</span>
        <span class="cov8" title="1">if cfg.Sync.SyncMode == "" </span><span class="cov0" title="0">{
                cfg.Sync.SyncMode = defaultCfg.Sync.SyncMode
        }</span>

        // Note: DryRun is a bool, so it will default to false if not specified in the config
}

// ValidateConfig checks if the configuration has all required values
func ValidateConfig(cfg Config) error <span class="cov8" title="1">{
        // Check DB configuration
        if cfg.DB.DSN == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database DSN is required")
        }</span>

        // Check Sync configuration
        <span class="cov8" title="1">if cfg.Sync.FilePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("sync file path is required")
        }</span>
        <span class="cov8" title="1">if cfg.Sync.TableName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("table name is required")
        }</span>
        // Note: If Columns are not specified in config, they will be derived from the CSV header.
        <span class="cov8" title="1">if cfg.Sync.SyncMode != "overwrite" &amp;&amp; cfg.Sync.SyncMode != "diff" </span><span class="cov0" title="0">{
                return fmt.Errorf("sync mode must be either 'overwrite' or 'diff'")
        }</span>
        <span class="cov8" title="1">if cfg.Sync.SyncMode == "diff" &amp;&amp; cfg.Sync.PrimaryKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("primary key is required for diff sync mode")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bytes"
        "context"
        "database/sql"
        "fmt"
        "log"
        "reflect"
        "slices"
        "strconv"
        "strings"
        "time"
        // "github.com/pkg/errors" // Removed as per user feedback
)

// PrimaryKey represents a type-preserving primary key structure that maintains
// both the original typed value and its string representation for safe comparison
// and SQL operations.
//
// Example usage:
//   pk1 := NewPrimaryKey(123)
//   pk2 := NewPrimaryKey("123")
//   if pk1.Equal(pk2) {
//       // Handle equal primary keys
//   }
type PrimaryKey struct {
        Value any // Original typed value from the data source
        Str   string      // String representation for display and SQL operations
}

// NewPrimaryKey creates a new PrimaryKey with type preservation and validation
func NewPrimaryKey(value any) PrimaryKey <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return PrimaryKey{Value: nil, Str: ""}
        }</span>
        <span class="cov8" title="1">return PrimaryKey{
                Value: value,
                Str:   convertValueToString(value),
        }</span>
}

// Equal compares two PrimaryKey values for equality using type-safe comparison
func (pk PrimaryKey) Equal(other PrimaryKey) bool <span class="cov8" title="1">{
        // Type-safe comparison using reflection for complex types
        return reflect.DeepEqual(pk.Value, other.Value) || pk.Str == other.Str
}</span>

// String returns the string representation of the PrimaryKey
func (pk PrimaryKey) String() string <span class="cov8" title="1">{
        return pk.Str
}</span>

// convertValueToString converts any value to string for comparison
// Uses fast type assertions for common types, fallback to reflection for others
func convertValueToString(val any) string <span class="cov8" title="1">{
        if val == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Fast path: Use type assertions for common types
        <span class="cov8" title="1">switch v := val.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case bool:<span class="cov8" title="1">
                return strconv.FormatBool(v)</span>
        case int:<span class="cov8" title="1">
                return strconv.Itoa(v)</span>
        case int8:<span class="cov8" title="1">
                return strconv.FormatInt(int64(v), 10)</span>
        case int16:<span class="cov8" title="1">
                return strconv.FormatInt(int64(v), 10)</span>
        case int32:<span class="cov8" title="1">
                return strconv.FormatInt(int64(v), 10)</span>
        case int64:<span class="cov8" title="1">
                return strconv.FormatInt(v, 10)</span>
        case uint:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(v), 10)</span>
        case uint8:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(v), 10)</span>
        case uint16:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(v), 10)</span>
        case uint32:<span class="cov8" title="1">
                return strconv.FormatUint(uint64(v), 10)</span>
        case uint64:<span class="cov8" title="1">
                return strconv.FormatUint(v, 10)</span>
        case float32:<span class="cov8" title="1">
                f := float64(v)
                if f == float64(int64(f)) </span><span class="cov0" title="0">{
                        return strconv.FormatInt(int64(f), 10)
                }</span>
                <span class="cov8" title="1">return strconv.FormatFloat(f, 'g', -1, 32)</span>
        case float64:<span class="cov8" title="1">
                if v == float64(int64(v)) </span><span class="cov8" title="1">{
                        return strconv.FormatInt(int64(v), 10)
                }</span>
                <span class="cov8" title="1">return strconv.FormatFloat(v, 'g', -1, 64)</span>
        case time.Time:<span class="cov8" title="1">
                return v.Format(time.RFC3339)</span>
        }

        // Slow path: Use reflection for other types
        <span class="cov8" title="1">rv := reflect.ValueOf(val)
        switch rv.Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                return val.(string)</span>
        case reflect.Bool:<span class="cov0" title="0">
                return strconv.FormatBool(val.(bool))</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return strconv.FormatInt(rv.Int(), 10)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return strconv.FormatUint(rv.Uint(), 10)</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                f := rv.Float()
                if f == float64(int64(f)) </span><span class="cov0" title="0">{
                        return strconv.FormatInt(int64(f), 10)
                }</span>
                <span class="cov0" title="0">return strconv.FormatFloat(f, 'g', -1, 64)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", val)</span>
        }
}

// UpdateOperation represents a single update operation with before and after states
type UpdateOperation struct {
        Before DataRecord
        After  DataRecord
}

// DiffOperations represents the operations to be performed during differential synchronization
type DiffOperations struct {
        ToInsert []DataRecord
        ToUpdate []UpdateOperation
        ToDelete []DataRecord
}

// ExecutionPlan represents the planned operations for data synchronization
type ExecutionPlan struct {
        SyncMode         string
        TableName        string
        FileRecordCount  int
        DbRecordCount    int
        InsertOperations []DataRecord
        UpdateOperations []UpdateOperation
        DeleteOperations []DataRecord
        AffectedColumns  []string // These will be the columns actually present in both CSV header and DB
        TimestampColumns []string
        ImmutableColumns []string
        PrimaryKey       string // Added to know which column is PK for display
}

// String returns a human-readable representation of the execution plan
func (p *ExecutionPlan) String() string <span class="cov8" title="1">{
        var buf bytes.Buffer
        now := time.Now()

        buf.WriteString("[DRY-RUN Mode] Execution Plan\n")
        buf.WriteString("----------------------------------------------------\n")
        buf.WriteString("Execution Summary:\n")
        buf.WriteString(fmt.Sprintf("- Sync Mode: %s\n", p.SyncMode))
        buf.WriteString(fmt.Sprintf("- Target Table: %s\n", p.TableName))
        buf.WriteString(fmt.Sprintf("- Records in File: %d\n", p.FileRecordCount))
        buf.WriteString(fmt.Sprintf("- Records in Database: %d\n", p.DbRecordCount))
        buf.WriteString("\nPlanned Operations:\n")

        if len(p.DeleteOperations) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\n1. DELETE Operations (%d records)\n", len(p.DeleteOperations)))
                buf.WriteString("----------------------------------------------------\n")
                for i, record := range p.DeleteOperations </span><span class="cov8" title="1">{
                        buf.WriteString(fmt.Sprintf("Record %d:\n", i+1))
                        for col, val := range record </span><span class="cov8" title="1">{
                                buf.WriteString(fmt.Sprintf("   %s: %v\n", col, val))
                        }</span>
                        <span class="cov8" title="1">buf.WriteString("\n")</span>
                }
        }

        <span class="cov8" title="1">if len(p.InsertOperations) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\n2. INSERT Operations (%d records)\n", len(p.InsertOperations)))
                buf.WriteString("----------------------------------------------------\n")
                buf.WriteString(fmt.Sprintf("Affected columns: %v\n\n", p.AffectedColumns))
                for i, record := range p.InsertOperations </span><span class="cov8" title="1">{
                        buf.WriteString(fmt.Sprintf("Record %d:\n", i+1))
                        for _, col := range p.AffectedColumns </span><span class="cov8" title="1">{
                                buf.WriteString(fmt.Sprintf("   %s: %v\n", col, record[col]))
                        }</span>
                        // Show timestamp values that will be set
                        <span class="cov8" title="1">for _, tsCol := range p.TimestampColumns </span><span class="cov8" title="1">{
                                buf.WriteString(fmt.Sprintf("   %s: %v (will be set)\n", tsCol, now.Format(time.RFC3339)))
                        }</span>
                        <span class="cov8" title="1">buf.WriteString("\n")</span>
                }
        }

        <span class="cov8" title="1">if len(p.UpdateOperations) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\n3. UPDATE Operations (%d records)\n", len(p.UpdateOperations)))
                buf.WriteString("----------------------------------------------------\n")

                // Filter out immutable columns from affected columns for UPDATE
                var updateableColumns []string
                for _, col := range p.AffectedColumns </span><span class="cov8" title="1">{
                        isImmutable := false
                        for _, immutableCol := range p.ImmutableColumns </span><span class="cov8" title="1">{
                                if col == immutableCol </span><span class="cov0" title="0">{
                                        isImmutable = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !isImmutable </span><span class="cov8" title="1">{
                                updateableColumns = append(updateableColumns, col)
                        }</span>
                }

                <span class="cov8" title="1">buf.WriteString(fmt.Sprintf("Affected columns: %v\n", updateableColumns))
                if len(p.ImmutableColumns) &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteString(fmt.Sprintf("Immutable columns (will not be updated): %v\n", p.ImmutableColumns))
                }</span>
                <span class="cov8" title="1">buf.WriteString("\n")

                for i, update := range p.UpdateOperations </span><span class="cov8" title="1">{
                        buf.WriteString(fmt.Sprintf("Record %d:\n", i+1))
                        // Display values for updateable columns
                        for _, col := range updateableColumns </span><span class="cov8" title="1">{
                                oldVal := update.Before[col]
                                newVal := update.After[col]
                                if oldVal != newVal </span><span class="cov8" title="1">{
                                        buf.WriteString(fmt.Sprintf("   %s: %v -&gt; %v\n", col, oldVal, newVal))
                                }</span> else<span class="cov8" title="1"> {
                                        buf.WriteString(fmt.Sprintf("   %s: %v (unchanged)\n", col, oldVal))
                                }</span>
                        }
                        // Display immutable columns with a note
                        <span class="cov8" title="1">for _, col := range p.ImmutableColumns </span><span class="cov8" title="1">{
                                if val, exists := update.After[col]; exists </span><span class="cov0" title="0">{
                                        buf.WriteString(fmt.Sprintf("   %s: %v (immutable)\n", col, val))
                                }</span>
                        }
                        // Show timestamp values that will be set
                        <span class="cov8" title="1">for _, tsCol := range p.TimestampColumns </span><span class="cov8" title="1">{
                                // Check if the timestamp column is not immutable
                                isImmutable := false
                                for _, immutableCol := range p.ImmutableColumns </span><span class="cov8" title="1">{
                                        if tsCol == immutableCol </span><span class="cov8" title="1">{
                                                isImmutable = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !isImmutable </span><span class="cov8" title="1">{
                                        buf.WriteString(fmt.Sprintf("   %s: %v (will be set)\n", tsCol, now.Format(time.RFC3339)))
                                }</span>
                        }
                        <span class="cov8" title="1">buf.WriteString("\n")</span>
                }
        }

        <span class="cov8" title="1">return buf.String()</span>
}

// getTableColumns retrieves the column names of a given table
func getTableColumns(ctx context.Context, tx *sql.Tx, tableName string) ([]string, error) <span class="cov8" title="1">{
        // Query to get column names, specific to MySQL. For other DBs, this might need adjustment.
        // Using `information_schema.columns` is a standard way.
        // Use parameterized query to prevent SQL injection
        query := "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = ? ORDER BY ORDINAL_POSITION"
        rows, err := tx.QueryContext(ctx, query, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query columns for table %s: %w", tableName, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var columns []string
        for rows.Next() </span><span class="cov8" title="1">{
                var columnName string
                if err := rows.Scan(&amp;columnName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan column name for table %s: %w", tableName, err)
                }</span>
                <span class="cov8" title="1">columns = append(columns, columnName)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating rows for table %s columns: %w", tableName, err)
        }</span>
        <span class="cov8" title="1">if len(columns) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no columns found for table %s or table does not exist", tableName)
        }</span>
        <span class="cov8" title="1">return columns, nil</span>
}

// findCommonColumns returns the intersection of CSV headers and DB table columns
func findCommonColumns(csvHeaders []string, dbTableColumns []string) []string <span class="cov8" title="1">{
        var commonColumns []string
        for _, csvHeader := range csvHeaders </span><span class="cov8" title="1">{
                if slices.Contains(dbTableColumns, csvHeader) </span><span class="cov8" title="1">{
                        if !slices.Contains(commonColumns, csvHeader) </span><span class="cov8" title="1">{
                                commonColumns = append(commonColumns, csvHeader)
                        }</span>
                }
        }
        <span class="cov8" title="1">return commonColumns</span>
}

// filterColumnsByConfig filters common columns using the config.Sync.Columns specification
func filterColumnsByConfig(commonColumns []string, configSyncColumns []string) []string <span class="cov8" title="1">{
        if len(configSyncColumns) == 0 </span><span class="cov8" title="1">{
                return commonColumns
        }</span>

        <span class="cov8" title="1">var filteredColumns []string
        for _, col := range commonColumns </span><span class="cov8" title="1">{
                if slices.Contains(configSyncColumns, col) </span><span class="cov8" title="1">{
                        filteredColumns = append(filteredColumns, col)
                }</span>
        }
        <span class="cov8" title="1">return filteredColumns</span>
}

// validatePrimaryKeyInColumns ensures the primary key is included in the sync columns
func validatePrimaryKeyInColumns(actualSyncColumns []string, pkName string) error <span class="cov8" title="1">{
        if pkName != "" &amp;&amp; !slices.Contains(actualSyncColumns, pkName) </span><span class="cov8" title="1">{
                return fmt.Errorf("configured primary key '%s' is not among the final actual sync columns: %v. It must be present in CSV header, DB table, and config.Sync.Columns (if specified)", pkName, actualSyncColumns)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// determineActualSyncColumns determines the columns to be synced.
// If configSyncColumns (config.Sync.Columns) is provided, it acts as a filter:
// actual columns will be the intersection of csvHeaders, dbTableColumns, and configSyncColumns.
// If configSyncColumns is empty, actual columns will be the intersection of csvHeaders and dbTableColumns.
func determineActualSyncColumns(csvHeaders []string, dbTableColumns []string, configSyncColumns []string, pkName string) ([]string, error) <span class="cov8" title="1">{
        if len(csvHeaders) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("CSV header is empty, cannot determine sync columns")
        }</span>

        // Step 1: Find intersection of CSV headers and DB table columns
        <span class="cov8" title="1">commonColumns := findCommonColumns(csvHeaders, dbTableColumns)
        if len(commonColumns) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no matching columns found between CSV header (%v) and DB table columns (%v)", csvHeaders, dbTableColumns)
        }</span>

        // Step 2: Apply config.Sync.Columns filter if specified
        <span class="cov8" title="1">actualSyncColumns := filterColumnsByConfig(commonColumns, configSyncColumns)
        if len(actualSyncColumns) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no matching columns after filtering with config.Sync.Columns (%v). Intersection of CSV headers (%v) and DB columns (%v) was (%v), but none of these were in config.Sync.Columns", configSyncColumns, csvHeaders, dbTableColumns, commonColumns)
        }</span>

        // Step 3: Validate primary key presence
        <span class="cov8" title="1">if err := validatePrimaryKeyInColumns(actualSyncColumns, pkName); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return actualSyncColumns, nil</span>
}

// generateExecutionPlan creates an execution plan for the sync operation
func generateExecutionPlan(ctx context.Context, tx *sql.Tx, config Config, fileRecords []DataRecord, actualSyncCols []string) (*ExecutionPlan, error) <span class="cov8" title="1">{
        plan := &amp;ExecutionPlan{
                SyncMode:         config.Sync.SyncMode,
                TableName:        config.Sync.TableName,
                FileRecordCount:  len(fileRecords),
                AffectedColumns:  actualSyncCols, // Use actual sync columns
                TimestampColumns: config.Sync.TimestampColumns,
                ImmutableColumns: config.Sync.ImmutableColumns,
                PrimaryKey:       config.Sync.PrimaryKey,
        }

        switch config.Sync.SyncMode </span>{
        case "overwrite":<span class="cov8" title="1">
                // For overwrite mode, all records will be deleted and reinserted
                dbRecords, _, err := getCurrentDBData(ctx, tx, config, actualSyncCols) // Pass actualSyncCols
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error getting current DB data for overwrite plan: %w", err)
                }</span>
                <span class="cov8" title="1">plan.DbRecordCount = len(dbRecords)
                plan.DeleteOperations = make([]DataRecord, 0, len(dbRecords))
                for _, record := range dbRecords </span><span class="cov8" title="1">{
                        plan.DeleteOperations = append(plan.DeleteOperations, record)
                }</span>
                <span class="cov8" title="1">plan.InsertOperations = fileRecords</span>

        case "diff":<span class="cov8" title="1">
                // For diff mode, calculate the actual differences
                if config.Sync.PrimaryKey == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("primary key is required for diff sync mode but is not configured")
                }</span>
                <span class="cov8" title="1">if !slices.Contains(actualSyncCols, config.Sync.PrimaryKey) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("primary key '%s' (from config) is not present in the actual columns to be synced (%v) based on CSV headers and DB schema. Diff mode cannot proceed", config.Sync.PrimaryKey, actualSyncCols)
                }</span>

                <span class="cov8" title="1">dbRecords, _, err := getCurrentDBData(ctx, tx, config, actualSyncCols) // Pass actualSyncCols
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error getting current DB data for diff plan: %w", err)
                }</span>
                <span class="cov8" title="1">plan.DbRecordCount = len(dbRecords)

                // Use existing diffData function to calculate differences
                toInsert, toUpdate, toDelete := diffData(config, fileRecords, dbRecords, actualSyncCols) // Pass actualSyncCols
                plan.InsertOperations = toInsert
                plan.UpdateOperations = toUpdate
                if config.Sync.DeleteNotInFile </span><span class="cov8" title="1">{
                        plan.DeleteOperations = toDelete
                }</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown sync mode: %s", config.Sync.SyncMode)</span>
        }

        <span class="cov8" title="1">return plan, nil</span>
}

// syncData synchronizes data between file and database
func syncData(ctx context.Context, db *sql.DB, config Config, fileRecords []DataRecord) error <span class="cov8" title="1">{
        // Early return only for diff mode without deleteNotInFile
        if len(fileRecords) == 0 </span><span class="cov8" title="1">{
                if config.Sync.SyncMode == "diff" &amp;&amp; !config.Sync.DeleteNotInFile </span><span class="cov0" title="0">{
                        log.Println("No records loaded from file. Nothing to sync.")
                        return nil
                }</span>
                // Log the intention for overwrite or diff+deleteNotInFile modes
                <span class="cov8" title="1">if config.Sync.SyncMode == "overwrite" </span><span class="cov8" title="1">{
                        log.Println("File is empty. In overwrite mode, all existing data will be deleted.")
                }</span> else<span class="cov0" title="0"> if config.Sync.SyncMode == "diff" &amp;&amp; config.Sync.DeleteNotInFile </span><span class="cov0" title="0">{
                        log.Println("File is empty. In diff mode with deleteNotInFile, all existing data may be deleted.")
                }</span>
        }

        <span class="cov8" title="1">tx, err := db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction start error: %w", err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback() // Rollback on error or if commit fails

        // Determine actual columns to sync
        var actualSyncColumns []string
        if len(fileRecords) &gt; 0 </span><span class="cov8" title="1">{
                // Normal case: get headers from file records
                fileHeaders := make([]string, 0, len(fileRecords[0]))
                for k := range fileRecords[0] </span><span class="cov8" title="1">{
                        fileHeaders = append(fileHeaders, k)
                }</span>
                <span class="cov8" title="1">slices.Sort(fileHeaders) // Ensure consistent order

                dbTableCols, err := getTableColumns(ctx, tx, config.Sync.TableName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get database table columns: %w", err)
                }</span>

                <span class="cov8" title="1">actualSyncColumns, err = determineActualSyncColumns(fileHeaders, dbTableCols, config.Sync.Columns, config.Sync.PrimaryKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to determine actual columns for synchronization: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Empty file case: use all DB columns for overwrite or diff+deleteNotInFile
                dbTableCols, err := getTableColumns(ctx, tx, config.Sync.TableName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get database table columns: %w", err)
                }</span>
                <span class="cov8" title="1">actualSyncColumns = dbTableCols

                // Primary key validation for diff mode
                if config.Sync.SyncMode == "diff" &amp;&amp; config.Sync.PrimaryKey == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("primary key must be configured for diff mode with deleteNotInFile when file is empty")
                }</span>
        }

        <span class="cov8" title="1">log.Printf("Actual columns to be synced: %v", actualSyncColumns)

        // For dry-run mode, generate and display execution plan
        if config.DryRun </span><span class="cov8" title="1">{
                plan, err := generateExecutionPlan(ctx, tx, config, fileRecords, actualSyncColumns) // Pass actualSyncCols
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error generating execution plan: %w", err)
                }</span>
                <span class="cov8" title="1">log.Print(plan.String())
                return nil</span> // Dry run ends here
        }

        <span class="cov8" title="1">switch config.Sync.SyncMode </span>{
        case "overwrite":<span class="cov8" title="1">
                err = syncOverwrite(ctx, tx, config, fileRecords, actualSyncColumns)</span> // Pass actualSyncCols
        case "diff":<span class="cov8" title="1">
                err = syncDiff(ctx, tx, config, fileRecords, actualSyncColumns)</span> // Pass actualSyncCols
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown sync mode: %s", config.Sync.SyncMode)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sync process error: %w", err)
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction commit error: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// syncOverwrite performs complete overwrite synchronization
func syncOverwrite(ctx context.Context, tx *sql.Tx, config Config, fileRecords []DataRecord, actualSyncCols []string) error <span class="cov8" title="1">{
        // 1. Delete existing data (DELETE)
        _, err := tx.ExecContext(ctx, fmt.Sprintf("DELETE FROM %s", config.Sync.TableName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error deleting data from table '%s': %w", config.Sync.TableName, err)
        }</span>
        <span class="cov8" title="1">log.Printf("Deleted existing data from table '%s'.", config.Sync.TableName)

        // 2. Insert all file data
        if len(fileRecords) == 0 </span><span class="cov8" title="1">{
                log.Println("No data to insert from file (file was empty or only header).")
                return nil
        }</span>
        <span class="cov8" title="1">if len(actualSyncCols) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no columns determined for sync, cannot insert data")
        }</span>

        <span class="cov8" title="1">err = bulkInsert(ctx, tx, config, fileRecords, actualSyncCols)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("data insertion error: %w", err)
        }</span>
        <span class="cov8" title="1">log.Printf("Inserted %d records using columns: %v.", len(fileRecords), actualSyncCols)

        return nil</span>
}

// validateDiffSyncRequirements validates the requirements for differential synchronization
func validateDiffSyncRequirements(config Config, actualSyncCols []string) error <span class="cov8" title="1">{
        if config.Sync.PrimaryKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("primary key is required for diff sync mode")
        }</span>
        <span class="cov8" title="1">if !slices.Contains(actualSyncCols, config.Sync.PrimaryKey) </span><span class="cov8" title="1">{
                return fmt.Errorf("primary key '%s' is not among the actual sync columns '%v', diff cannot proceed", config.Sync.PrimaryKey, actualSyncCols)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// executeSyncOperations executes the planned sync operations
func executeSyncOperations(ctx context.Context, tx *sql.Tx, config Config, operations DiffOperations, actualSyncCols []string) error <span class="cov8" title="1">{
        // INSERT processing
        if len(operations.ToInsert) &gt; 0 </span><span class="cov8" title="1">{
                err := bulkInsert(ctx, tx, config, operations.ToInsert, actualSyncCols)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("INSERT error: %w", err)
                }</span>
                <span class="cov8" title="1">log.Printf("Inserted %d records.", len(operations.ToInsert))</span>
        }

        // UPDATE processing
        <span class="cov8" title="1">if len(operations.ToUpdate) &gt; 0 </span><span class="cov8" title="1">{
                updateRecords := make([]DataRecord, len(operations.ToUpdate))
                for i, op := range operations.ToUpdate </span><span class="cov8" title="1">{
                        updateRecords[i] = op.After
                }</span>
                <span class="cov8" title="1">err := bulkUpdate(ctx, tx, config, updateRecords, actualSyncCols)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("UPDATE error: %w", err)
                }</span>
                <span class="cov8" title="1">log.Printf("Updated %d records.", len(operations.ToUpdate))</span>
        }

        // DELETE processing
        <span class="cov8" title="1">if len(operations.ToDelete) &gt; 0 &amp;&amp; config.Sync.DeleteNotInFile </span><span class="cov8" title="1">{
                err := bulkDelete(ctx, tx, config, operations.ToDelete)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("DELETE error: %w", err)
                }</span>
                <span class="cov8" title="1">log.Printf("Deleted %d records.", len(operations.ToDelete))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// syncDiff performs differential synchronization
func syncDiff(ctx context.Context, tx *sql.Tx, config Config, fileRecords []DataRecord, actualSyncCols []string) error <span class="cov8" title="1">{
        // Validate requirements for differential sync
        if err := validateDiffSyncRequirements(config, actualSyncCols); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get current data from DB
        <span class="cov8" title="1">dbRecords, _, err := getCurrentDBData(ctx, tx, config, actualSyncCols)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("DB data retrieval error: %w", err)
        }</span>

        // Compare file data with DB data
        <span class="cov8" title="1">toInsert, toUpdate, toDelete := diffData(config, fileRecords, dbRecords, actualSyncCols)
        operations := DiffOperations{
                ToInsert: toInsert,
                ToUpdate: toUpdate,
                ToDelete: toDelete,
        }
        log.Printf("Difference detection result: Insert %d, Update %d, Delete %d",
                len(operations.ToInsert), len(operations.ToUpdate), len(operations.ToDelete))

        // Execute the planned operations
        return executeSyncOperations(ctx, tx, config, operations, actualSyncCols)</span>
}

// getCurrentDBData retrieves current data from database (for differential sync)
// It now uses actualSyncCols to determine which columns to SELECT.
// The Primary Key must be part of actualSyncCols for diff to work.
func getCurrentDBData(ctx context.Context, tx *sql.Tx, config Config, actualSyncCols []string) (map[string]DataRecord, map[string]PrimaryKey, error) <span class="cov8" title="1">{
        if len(actualSyncCols) == 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("no columns specified to fetch from database")
        }</span>

        <span class="cov8" title="1">selectCols := slices.Clone(actualSyncCols)
        // Ensure PK is in selectCols if it's configured and not already present.
        // This is vital for mapping records.
        if config.Sync.PrimaryKey != "" &amp;&amp; !slices.Contains(selectCols, config.Sync.PrimaryKey) </span><span class="cov0" title="0">{
                // This situation implies that the PK configured in yml is not in the CSV header
                // or not in the DB table, which should have been caught by determineActualSyncColumns.
                // If determineActualSyncColumns ensures PK is present if it's a valid sync col, this append might be redundant
                // or indicate a logic gap. For safety, we ensure it's selected if configured.
                // However, if PK is not in actualSyncCols, it means it wasn't a common column.
                // This function should only select columns that are in actualSyncCols.
                // The check for PK presence in actualSyncCols should be done *before* calling this.
                // So, if PK is not in actualSyncCols here, it's a problem.
                return nil, nil, fmt.Errorf("primary key '%s' is configured but not in actual sync columns %v; cannot fetch DB data correctly for diff", config.Sync.PrimaryKey, actualSyncCols)
        }</span>

        <span class="cov8" title="1">query := fmt.Sprintf("SELECT %s FROM %s",
                strings.Join(selectCols, ","), // Use selectCols which is a clone of actualSyncCols
                config.Sync.TableName)

        rows, err := tx.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("query execution error (%s): %w", query, err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        cols, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("column name retrieval error: %w", err)
        }</span>

        <span class="cov8" title="1">dbData := make(map[string]DataRecord) // Map with primary key string as key
        pkMap := make(map[string]PrimaryKey)  // Map to store PrimaryKey objects
        vals := make([]any, len(cols))
        scanArgs := make([]any, len(cols))
        for i := range vals </span><span class="cov8" title="1">{
                scanArgs[i] = &amp;vals[i]
        }</span>

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(scanArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("row data scan error: %w", err)
                }</span>
                <span class="cov8" title="1">record := make(DataRecord)
                var pkValue any
                for i, colName := range cols </span><span class="cov8" title="1">{
                        // Values from DB might be []byte or specific types, convert to string
                        val := vals[i]
                        var strVal string
                        if b, ok := val.([]byte); ok </span><span class="cov8" title="1">{
                                strVal = string(b)
                        }</span> else<span class="cov8" title="1"> if val != nil </span><span class="cov8" title="1">{
                                strVal = fmt.Sprintf("%v", val) // Handle other types
                        }</span> // NULL might be handled as empty string or separately

                        <span class="cov8" title="1">record[colName] = strVal
                        if colName == config.Sync.PrimaryKey </span><span class="cov8" title="1">{
                                // For PrimaryKey, use the string representation to ensure consistency
                                pkValue = strVal
                        }</span>
                }
                <span class="cov8" title="1">if pkValue == nil </span><span class="cov0" title="0">{
                        // Skip or error if primary key can't be obtained
                        log.Printf("Warning: Found record with nil primary key value. Skipping. Record: %v", record)
                        continue</span>
                }
                <span class="cov8" title="1">pk := NewPrimaryKey(pkValue)
                if pk.Str == "" </span><span class="cov0" title="0">{
                        log.Printf("Warning: Found record with empty primary key after string conversion. Skipping. Record: %v", record)
                        continue</span>
                }
                <span class="cov8" title="1">dbData[pk.Str] = record
                pkMap[pk.Str] = pk</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("row processing error: %w", err)
        }</span>

        <span class="cov8" title="1">return dbData, pkMap, nil</span>
}

// extractPrimaryKeyValue extracts and validates primary key value from a record
func extractPrimaryKeyValue(record DataRecord, primaryKey string) (PrimaryKey, bool) <span class="cov8" title="1">{
        pkValue, pkExists := record[primaryKey]
        if !pkExists || pkValue == nil </span><span class="cov8" title="1">{
                return PrimaryKey{}, false
        }</span>
        <span class="cov8" title="1">pk := NewPrimaryKey(pkValue)
        if pk.Str == "" </span><span class="cov0" title="0">{
                return PrimaryKey{}, false
        }</span>
        <span class="cov8" title="1">return pk, true</span>
}

// compareRecords compares two records and returns true if they differ
func compareRecords(fileRecord, dbRecord DataRecord, actualSyncCols []string, primaryKey string) bool <span class="cov8" title="1">{
        for _, col := range actualSyncCols </span><span class="cov8" title="1">{
                if col == primaryKey </span><span class="cov8" title="1">{
                        continue</span> // Don't compare PK value itself for diff content
                }
                <span class="cov8" title="1">fileVal, fileColExists := fileRecord[col]
                dbVal, dbColExists := dbRecord[col]

                if !fileColExists &amp;&amp; dbColExists </span><span class="cov0" title="0">{
                        return true
                }</span> else<span class="cov8" title="1"> if fileColExists &amp;&amp; !dbColExists </span><span class="cov0" title="0">{
                        return true
                }</span> else<span class="cov8" title="1"> if fileColExists &amp;&amp; dbColExists </span><span class="cov8" title="1">{
                        fileStr := convertValueToString(fileVal)
                        if fileStr != dbVal </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// processFileRecords processes file records and determines insert/update operations
func processFileRecords(fileRecords []DataRecord, dbRecords map[string]DataRecord, config Config, actualSyncCols []string) ([]DataRecord, []UpdateOperation, map[string]bool) <span class="cov8" title="1">{
        var toInsert []DataRecord
        var toUpdate []UpdateOperation
        fileKeys := make(map[string]bool)

        for _, fileRecord := range fileRecords </span><span class="cov8" title="1">{
                pk, isValid := extractPrimaryKeyValue(fileRecord, config.Sync.PrimaryKey)
                if !isValid </span><span class="cov0" title="0">{
                        log.Printf("Warning: Record in file is missing primary key '%s' value or key itself. Skipping: %v", config.Sync.PrimaryKey, fileRecord)
                        continue</span>
                }
                <span class="cov8" title="1">fileKeys[pk.Str] = true

                dbRecord, existsInDB := dbRecords[pk.Str]
                if !existsInDB </span><span class="cov8" title="1">{
                        toInsert = append(toInsert, fileRecord)
                }</span> else<span class="cov8" title="1"> if compareRecords(fileRecord, dbRecord, actualSyncCols, config.Sync.PrimaryKey) </span><span class="cov8" title="1">{
                        toUpdate = append(toUpdate, UpdateOperation{
                                Before: dbRecord,
                                After:  fileRecord,
                        })
                }</span>
        }

        <span class="cov8" title="1">return toInsert, toUpdate, fileKeys</span>
}

// findRecordsToDelete identifies records that need to be deleted
func findRecordsToDelete(dbRecords map[string]DataRecord, fileKeys map[string]bool, deleteNotInFile bool) []DataRecord <span class="cov8" title="1">{
        if !deleteNotInFile </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var toDelete []DataRecord
        for pkStr, dbRecord := range dbRecords </span><span class="cov8" title="1">{
                if !fileKeys[pkStr] </span><span class="cov8" title="1">{
                        toDelete = append(toDelete, dbRecord)
                }</span>
        }
        <span class="cov8" title="1">return toDelete</span>
}

// diffData compares file data with DB data (for differential sync)
// It now uses actualSyncCols to determine which columns to compare.
func diffData(
        config Config,
        fileRecords []DataRecord,
        dbRecords map[string]DataRecord,
        actualSyncCols []string,
) (toInsert []DataRecord, toUpdate []UpdateOperation, toDelete []DataRecord) <span class="cov8" title="1">{

        if config.Sync.PrimaryKey == "" </span><span class="cov0" title="0">{
                log.Println("Error: Primary key not configured, cannot perform diff.") // Should be caught earlier
                return
        }</span>

        // Process file records to determine insert/update operations
        <span class="cov8" title="1">toInsert, toUpdate, fileKeys := processFileRecords(fileRecords, dbRecords, config, actualSyncCols)

        // Identify records to delete
        toDelete = findRecordsToDelete(dbRecords, fileKeys, config.Sync.DeleteNotInFile)

        return</span>
}

// bulkInsert performs bulk insertion of records using actualSyncCols
func bulkInsert(ctx context.Context, tx *sql.Tx, config Config, records []DataRecord, actualSyncCols []string) error <span class="cov8" title="1">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if len(actualSyncCols) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no columns specified for insert")
        }</span>

        // Columns for INSERT statement are actualSyncCols + timestamp columns not already in actualSyncCols
        <span class="cov8" title="1">insertStatementCols := slices.Clone(actualSyncCols)
        activeTimestampCols := []string{} // Timestamp columns that are not part of actualSyncCols but need to be set
        for _, tsCol := range config.Sync.TimestampColumns </span><span class="cov8" title="1">{
                if !slices.Contains(insertStatementCols, tsCol) </span><span class="cov8" title="1">{
                        insertStatementCols = append(insertStatementCols, tsCol)
                        activeTimestampCols = append(activeTimestampCols, tsCol)
                }</span>
        }

        <span class="cov8" title="1">valueStrings := make([]string, 0, len(records))
        valueArgs := make([]any, 0, len(records)*len(insertStatementCols))
        placeholders := make([]string, len(insertStatementCols))
        for i := range placeholders </span><span class="cov8" title="1">{
                placeholders[i] = "?"
        }</span>
        <span class="cov8" title="1">placeholderStr := fmt.Sprintf("(%s)", strings.Join(placeholders, ","))

        now := time.Now()
        for _, record := range records </span><span class="cov8" title="1">{
                valueStrings = append(valueStrings, placeholderStr)
                for _, col := range actualSyncCols </span><span class="cov8" title="1">{ // Iterate actualSyncCols for record values
                        valueArgs = append(valueArgs, record[col])
                }</span>
                <span class="cov8" title="1">for range activeTimestampCols </span><span class="cov8" title="1">{ // Add values for the additionally active timestamp columns
                        valueArgs = append(valueArgs, now)
                }</span>
        }

        <span class="cov8" title="1">stmt := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s",
                config.Sync.TableName,
                strings.Join(insertStatementCols, ","),
                strings.Join(valueStrings, ","))

        _, err := tx.ExecContext(ctx, stmt, valueArgs...)
        return err</span>
}

// bulkUpdate performs updates for multiple records using actualSyncCols
func bulkUpdate(ctx context.Context, tx *sql.Tx, config Config, records []DataRecord, actualSyncCols []string) error <span class="cov8" title="1">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if config.Sync.PrimaryKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("primary key not specified for update")
        }</span>

        <span class="cov8" title="1">setClauses := []string{}
        // Determine columns to include in SET clause
        // These are actualSyncCols excluding PK and immutable columns
        updatableRecordCols := []string{} // Columns from record to use in SET
        for _, col := range actualSyncCols </span><span class="cov8" title="1">{
                if col != config.Sync.PrimaryKey &amp;&amp; !slices.Contains(config.Sync.ImmutableColumns, col) </span><span class="cov8" title="1">{
                        setClauses = append(setClauses, fmt.Sprintf("%s = ?", col))
                        updatableRecordCols = append(updatableRecordCols, col)
                }</span>
        }

        <span class="cov8" title="1">activeTimestampSetCols := []string{} // Timestamp columns to SET that are not in actualSyncCols
        for _, tsCol := range config.Sync.TimestampColumns </span><span class="cov8" title="1">{
                // Add to SET if it's a timestamp column, not immutable, and not already handled via actualSyncCols
                if !slices.Contains(config.Sync.ImmutableColumns, tsCol) &amp;&amp; !slices.Contains(actualSyncCols, tsCol) </span><span class="cov8" title="1">{
                        setClauses = append(setClauses, fmt.Sprintf("%s = ?", tsCol))
                        activeTimestampSetCols = append(activeTimestampSetCols, tsCol)
                }</span>
        }

        <span class="cov8" title="1">if len(setClauses) == 0 </span><span class="cov0" title="0">{
                log.Println("No columns to update after excluding primary key and immutable columns.")
                return nil
        }</span>

        <span class="cov8" title="1">stmtSQL := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?",
                config.Sync.TableName,
                strings.Join(setClauses, ", "),
                config.Sync.PrimaryKey)

        stmt, err := tx.PrepareContext(ctx, stmtSQL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("UPDATE preparation error: %w", err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()

        now := time.Now()
        for _, record := range records </span><span class="cov8" title="1">{
                args := make([]any, 0, len(updatableRecordCols)+len(activeTimestampSetCols)+1)
                for _, col := range updatableRecordCols </span><span class="cov8" title="1">{
                        args = append(args, record[col])
                }</span>
                <span class="cov8" title="1">for range activeTimestampSetCols </span><span class="cov8" title="1">{
                        args = append(args, now)
                }</span>
                <span class="cov8" title="1">args = append(args, record[config.Sync.PrimaryKey]) // PK for WHERE

                _, err = stmt.ExecContext(ctx, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("UPDATE execution error (PK: %s): %w", record[config.Sync.PrimaryKey], err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// bulkDelete performs deletion of multiple records
// This function does not need actualSyncCols as it only uses the Primary Key.
func bulkDelete(ctx context.Context, tx *sql.Tx, config Config, records []DataRecord) error <span class="cov8" title="1">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">pkValues := make([]any, 0, len(records))
        placeholders := make([]string, 0, len(records))
        for _, record := range records </span><span class="cov8" title="1">{
                pkValues = append(pkValues, record[config.Sync.PrimaryKey])
                placeholders = append(placeholders, "?")
        }</span>

        <span class="cov8" title="1">stmt := fmt.Sprintf("DELETE FROM %s WHERE %s IN (%s)",
                config.Sync.TableName,
                config.Sync.PrimaryKey,
                strings.Join(placeholders, ","))

        _, err := tx.ExecContext(ctx, stmt, pkValues...)
        return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "encoding/csv"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

// DataRecord represents one record of data loaded from file
// A map with column names as keys
type DataRecord map[string]any

// convertJSONValueToString converts JSON values to strings while preserving type information
// This function handles different JSON types appropriately:
// - Numbers: converted to strings without scientific notation when possible
// - Booleans: "true" or "false"
// - Strings: preserved as-is
// - null: converted to empty string
// convertValue converts JSON values to appropriate Go types
func convertValue(val any) any <span class="cov8" title="1">{
        if val == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Try to convert string values that look like RFC3339 timestamps to time.Time
        <span class="cov8" title="1">if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                if t, err := time.Parse(time.RFC3339, str); err == nil </span><span class="cov8" title="1">{
                        return t
                }</span>
                <span class="cov8" title="1">return str</span>
        }

        // Return other types as-is
        <span class="cov8" title="1">return val</span>
}

// Loader is the basic interface for data loaders
type Loader interface {
        // Load loads data according to specified column definitions
        // For CSVLoader, the columns argument is ignored and headers are read from the CSV file.
        Load(columns []string) ([]DataRecord, error)
}

// CSVLoader loads data from CSV files
type CSVLoader struct {
        Delimiter rune // CSV delimiter character
        // HasHeader bool   // Whether file has a header row - For CSV, we now always assume a header
        FilePath string // Path to file to be loaded
}

// NewCSVLoader creates a new CSV loader instance
func NewCSVLoader(filePath string) *CSVLoader <span class="cov8" title="1">{
        return &amp;CSVLoader{
                Delimiter: ',', // Default is comma delimiter
                // HasHeader: true, // Default is no header - Now always true for CSV
                FilePath: filePath,
        }
}</span>

// WithDelimiter returns a CSV loader with the specified delimiter
func (l *CSVLoader) WithDelimiter(delimiter rune) *CSVLoader <span class="cov8" title="1">{
        l.Delimiter = delimiter
        return l
}</span>

// Load loads data from CSV file.
// The 'columns' argument is ignored for CSVLoader; column names are derived from the CSV header.
func (l *CSVLoader) Load(_ []string) ([]DataRecord, error) <span class="cov8" title="1">{
        file, err := os.Open(l.FilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot open file '%s': %w", l.FilePath, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        reader := csv.NewReader(file)
        reader.Comma = l.Delimiter

        // Read header row
        headerNames, err := reader.Read()
        if err != nil </span><span class="cov8" title="1">{
                if err == csv.ErrFieldCount || errors.Is(err, io.EOF) </span><span class="cov8" title="1">{ // Check for empty file or just header
                        return nil, fmt.Errorf("CSV file '%s' must contain a header row and at least one data row: %w", l.FilePath, err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error reading header row from CSV file '%s': %w", l.FilePath, err)</span>
        }
        <span class="cov8" title="1">if len(headerNames) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV file '%s' header row is empty", l.FilePath)
        }</span>

        <span class="cov8" title="1">csvRows, err := reader.ReadAll()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error reading CSV data rows from '%s': %w", l.FilePath, err)
        }</span>

        <span class="cov8" title="1">var records []DataRecord
        for i, row := range csvRows </span><span class="cov8" title="1">{
                // Line number reported to user should be i+2 because 1 for header, 1 for 0-indexed loop
                if len(row) != len(headerNames) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("CSV file '%s', line %d: column count (%d) does not match header column count (%d)", l.FilePath, i+2, len(row), len(headerNames))
                }</span>
                <span class="cov8" title="1">record := make(DataRecord)
                for j, colName := range headerNames </span><span class="cov8" title="1">{
                        record[colName] = convertValue(row[j])
                }</span>
                <span class="cov8" title="1">records = append(records, record)</span>
        }
        <span class="cov8" title="1">return records, nil</span>
}

// JSONLoader loads data from JSON files
type JSONLoader struct {
        FilePath string // Path to file to be loaded
}

// NewJSONLoader creates a new JSON loader instance
func NewJSONLoader(filePath string) *JSONLoader <span class="cov8" title="1">{
        return &amp;JSONLoader{
                FilePath: filePath,
        }
}</span>

// Load loads data from JSON file.
// It expects an array of objects. If 'columns' is empty, it auto-detects all keys from the first object.
// If 'columns' is specified, it filters to only those columns.
func (l *JSONLoader) Load(columns []string) ([]DataRecord, error) <span class="cov8" title="1">{
        fileData, err := os.ReadFile(l.FilePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot read JSON file '%s': %w", l.FilePath, err)
        }</span>

        <span class="cov8" title="1">if len(fileData) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("JSON file '%s' is empty", l.FilePath)
        }</span>

        <span class="cov8" title="1">var jsonData []map[string]any
        err = json.Unmarshal(fileData, &amp;jsonData)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error unmarshalling JSON data from '%s': %w", l.FilePath, err)
        }</span>

        <span class="cov8" title="1">if len(jsonData) == 0 </span><span class="cov8" title="1">{
                return nil, nil // Return empty slice for empty JSON array
        }</span>

        // Auto-detect columns from the first JSON object if not specified
        <span class="cov8" title="1">var actualColumns []string
        if len(columns) == 0 </span><span class="cov8" title="1">{
                // Get all keys from the first object
                for key := range jsonData[0] </span><span class="cov8" title="1">{
                        actualColumns = append(actualColumns, key)
                }</span>
                // Sort for consistent ordering
                <span class="cov8" title="1">sort.Strings(actualColumns)</span>
        } else<span class="cov8" title="1"> {
                actualColumns = columns
        }</span>

        <span class="cov8" title="1">var records []DataRecord
        for i, jsonObj := range jsonData </span><span class="cov8" title="1">{
                record := make(DataRecord)
                for _, colName := range actualColumns </span><span class="cov8" title="1">{
                        val, ok := jsonObj[colName]
                        if !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("JSON file '%s', record %d: missing required key '%s'", l.FilePath, i, colName)
                        }</span>
                        <span class="cov8" title="1">record[colName] = convertValue(val)</span>
                }
                <span class="cov8" title="1">records = append(records, record)</span>
        }
        <span class="cov8" title="1">return records, nil</span>
}

// GetLoader creates a loader instance for the specified file path
// Returns appropriate loader based on file extension
func GetLoader(filePath string) (Loader, error) <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filePath))
        switch ext </span>{
        case ".csv":<span class="cov8" title="1">
                return NewCSVLoader(filePath), nil</span>
        case ".json":<span class="cov8" title="1">
                return NewJSONLoader(filePath), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported file type: '%s'. Only .csv and .json are supported", ext)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "database/sql"
        "flag"
        "fmt"
        "log"
        "os"
        "time"

        _ "github.com/go-sql-driver/mysql"
)

// CustomUsage prints a custom formatted usage message
func CustomUsage() <span class="cov0" title="0">{
        fmt.Fprintf(os.Stdout, `mydatasyncer - Database Synchronization Tool

Usage:
  mydatasyncer [options]

Options:
`)
        flag.PrintDefaults()
        fmt.Fprintf(os.Stdout, `
Examples:
  Basic usage:
    $ mydatasyncer -config ./config.yml

  Preview changes:
    $ mydatasyncer -config ./config.yml -dry-run
`)
}</span>

func main() <span class="cov0" title="0">{
        // Set custom usage function
        flag.Usage = CustomUsage

        // Define command-line flags with detailed descriptions
        configPath := flag.String("config", "", `Path to the configuration file
        Default: mydatasyncer.yml in the current directory
        YAML format configuration file containing database connection details and column mappings`)

        dryRun := flag.Bool("dry-run", false, `Execute in dry-run mode
        Preview changes that would be made without applying them to the database
        Use this to verify changes before actual synchronization`)

        flag.Parse()

        if err := RunApp(*configPath, *dryRun); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Application error: %v", err)
        }</span>
}

func RunApp(configPath string, dryRun bool) error <span class="cov8" title="1">{
        // Create a context with timeout for the entire process
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        // 1. Load configuration
        config := LoadConfig(configPath)
        config.DryRun = dryRun // Set dry-run mode from command line flag

        if dryRun </span><span class="cov0" title="0">{
                log.Println("Running in DRY-RUN mode - No changes will be applied to the database")
        }</span>

        <span class="cov8" title="1">if err := ValidateConfig(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration error: %w", err)
        }</span>

        // 2. Database connection
        <span class="cov8" title="1">db, err := sql.Open("mysql", config.DB.DSN)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connection error: %w", err)
        }</span>
        <span class="cov8" title="1">defer db.Close()
        err = db.PingContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database connectivity error: %w", err)
        }</span>
        <span class="cov8" title="1">log.Println("Database connection successful")

        // 3. File loading and parsing
        records, err := loadDataFromFile(&amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("file reading error: %w", err)
        }</span>
        <span class="cov8" title="1">log.Printf("Loaded %d records from file.", len(records))

        // 4. Synchronization process - now uses the function from dbsync.go
        err = syncData(ctx, db, config, records)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("data synchronization error: %w", err)
        }</span>

        <span class="cov8" title="1">log.Println("Data synchronization completed successfully.")
        return nil</span>
}

// loadDataFromFile loads data from file using the integrated loader functionality
func loadDataFromFile(config *Config) ([]DataRecord, error) <span class="cov8" title="1">{
        dataLoader, err := GetLoader(config.Sync.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating loader for %s: %w", config.Sync.FilePath, err)
        }</span>
        <span class="cov8" title="1">return dataLoader.Load(config.Sync.Columns)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
